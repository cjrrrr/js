    当然，承诺让你更接近你想去的地方。不幸的是，所有这些方法限制了您的代码响应和反应能力；换句话说，在请失败或重试拒绝的承诺的情况下，您不能轻易地返回默认值。通过在代码中引入副作用，可以绕过链中的默认值。您可以在第三方库的帮助下实现重试，例如Q.JS（http://Github.com/kRISKOWAL/Q） 但更重要的是，从我们之前的讨论中回想，承诺模型是单一异步值，而不是广泛的，它们是在结合功能和反应式编程时解决的问题类型，并且使事情更糟，就算没有提供错误处理，承诺也可以吞并异常。让我们更详细地检查这些命令式错误处理机制与反应式应用程序不兼容的原因。



<font color="#63B8FF">7.2强制错误处理之间的不兼容性</br>技术与功能和活性代码库</font>
----------
    强制Java中抛出和捕获异常的结构化机制脚本代码在使用功能或反应风格时有许多缺点。一般来说，抛出异常的函数
 
* 不能像其他功能伪像一样组成或链接。
* 违反纯函数的原理，提倡单一的、可预测的值，因为抛出异常构成了您的另一个退出路径。函数调用。
* 由于堆叠的意外退绕而产生副作用影响整个系统，而不仅仅是函数调用或流声明。
* 违反了非局部性的原则，因为用于恢复的代码错误与发起函数调用距离较远。当引发错误时，函数离开本地堆栈和环境，例如：
    >try {
    
    >>let record = findRecordById('123');
    
    >>... potentially many lines of code in between

    >}

    >catch (e) {

    >>console.log('ERROR: Record not found!');
    
    >>// Handle error here

    >}

* 对调用方承担大量的责任来声明匹配的catch块。
* 管理特定的异常而不是仅仅担心函数的单个返回值。
* 很难异步使用。当包含同步代码时，尝试/捕获习惯用法是有效的，其中错误是由封闭的尝试块语法限制的。此代码是可预测的，不受时间和延迟的影响。另一方面，异步函数是不可预测的，并且通常提供错误回调机制，以便将程序控制返回给用户。当多个错误条件创建嵌套级别的异常处理块时，很难使用：
    ```
    let record = null;
    try {
        record = findRecordByName('RecordA');
    }
    catch (e) {
        console.log('ERROR: Cannot locate record by name');
        try {
            record = findRecordById('123');
        }
        catch (e) {
            console.log('ERROR: Record is nowhere to be found!');
        }
    }
    ```
读完所有这些陈述之后，你可能在问自己，“将异常完全排除在桌面之外吗？”，我们当然不相信。在实践中，他们永远不会离开桌面，因为有很多因素在你的控制之外，你可能需要解释，比如系统或环境错误或调用第三方代码。我们并不是建议你们不要使用例外，因为它们确实有目的，只是为了真正的例外条件而使用它们。当您需要使用异常或处理错误时，功能性方法是允许功能数据类型抽象它们远离主业务逻辑；这会阻止您创建难以维护的副作用或代码。

<font color="#63B8FF">7.3 理解函数错误处理方法</font>
-------

错误处理的功能性方法非常简单。正如我们之前提到的，在这本书中，我们不会深入到任何功能性的话题。因此，我们将提供这种方法的简单化视图，以帮助您更好地理解RxJS的错误处理机制的设计。这里的目标是改造或成为一流公民。围绕一个函数或代码体的包装器，它有可能引发异常。如果你想一想，那就是当你使用Test/catch块时一直在做的事情。函数 *FordReordById（）* 可以在没有找到数据库记录的情况下抛出异常，如图7.3所示。
![](trans1.png)

<center><font size="2">图7.3 一个try/catch块创建了一个保护代码的不可见的部分</font><br /></center>

![](trans2.png)

<font size="2">图7.4 使用名为“尝试”的数据类型，使应用程序的第一类公民成为错误。这可以用来包装任何值，然后安全地应用或映射函数。如果函数调用成功（未产生异常），返回一个名为成功的数据类型；否则返回一个失败对象。</font><br />

尝试块在函数调用周围创建一个不可见的包围盒，这样您就可以在catch块中实现所有的错误处理逻辑。在功能世界中，您将用一个称为“尝试”的数据类型来重构这个容器。

<font color="#dd0000" size="5">注意</font><br /> 在这里介绍的FP数据类型是FP中常见的模式。只是作为理论建构。当我们讨论观测值如何实现这种模式，稍后这将帮助您。

可以使用此类型将函数应用或映射到某个值。这相当于调用具有该参数的函数。有了这个额外的管道，尝试允许您提供必要的抽象来返回一个类型成功的对象，如果找到了一个记录对象；否则，一个类型失败的对象，发出了意想不到的事情发生的信号。请注意，这要求输入是一个函数，以便它能够正确捕获抛出的异常:

```
Try.of(() => findRecordById('123')); //-> Success(Record)
Try.of(() => findRecordById('456')); //-> Failure
Try.of(() => findRecordById('xxxxx'))
.getOrElse(new Record(...)); //-> Default value
```

现在，就像任何函数数据类型一样，假设尝试也有一个MAP（）运算符，如果找到的话，可以使用它来执行解析对象上的任何动作：
```
Try.of(() => findRecordById('123')).map(processRecord);
```

使用Type作为函数的返回类型非常方便，因为不仅保护了它从可能的空访问返回的值，而且还让用户知道这个特定函数可能产生无效的结果，这是自文档化的。这就是为什么Scala、Java和Haskell等其他语言为这个数据类型提供本地API的原因。

为了我们讨论的目的，我们展示了下一个列表中的一些尝试，以及它的派生类型的成功和失败。

<center><table><tr><td bgcolor=#7D9EC0>表7.4 尝试函数数据类型的内部结构</td></tr></table></center>
---

![](trans3.png)

<font color="#7D9EC0" size="5">语法</font><br /> 
表7.4使用ES6中的类语法来模拟TIVE数据类型。我们只使用类，因为它们在语法上比使用函数和对象原型要短。正如您现在可能知道的，类不过是JavaScript现有基于原型的继承的语法糖。是否决定使用函数或类语法实现完全取决于你。

表7.4仅显示了此功能数据类型的一些关键细节。尝试两种模式：

    * 如果Test<记录>的实例表示成功的计算，则它是成功的实例<记录>，内部用于继续链。

    * 另一方面，如果它表示发生错误的计算，则是失败的实例<错误>，包装错误对象或异常。

使用此实现的是一种简单的数据类型，允许您在对象上进行流水线、Orcon操作、沿途捕获异常，而不影响业务逻辑和隐藏必要的尝试/捕获结构。下面是你如何使用它。假设您执行一个函数进程记录（），该函数在从数据库中提取的记录上工作。如果没有找到记录，PrimeRealCordNo（）将引发异常：
```
let record = Try.of(() => findRecordById('123')
    .map(processRecord)
    .getOrElse(new Record('123', 'RecordA'));
```

此代码通过将值提升到TIVE上下文，然后将函数映射到它来工作。MAP（）是try/catch逻辑在一个地方合并的地方。可以说，与下面的代码相比，此代码更加可读和纯净：
```
let record;
try {
    record = findRecordById('123');
    processRecord(record);
}
catch (e) {
    record = new Record('123', 'RecordA');
}
```

在函数的情况下，如果进程操作失败，这个逻辑中的任何东西实际上都不会改变，因为错误会通过故障实例在内部传播，最终导致创建并返回默认记录对象的GETORCELL（）函数。这种简单的设计模式是非常强大的，因为它将错误处理完全从业务逻辑中抽象出来，这样您的函数只需要编写代码来解决手头的任务，同时还可以保持副作用。您可以在图7.5中看到这一点。

关于传播的变化和函数映射的讨论是否敲响了警钟？没错！可观测数据类型的工作方式完全相同，现在您将看到它是如何实现自己的异常处理运算符的。